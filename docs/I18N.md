# Internationalization (i18n) Guide

## Overview

DocLayout includes a comprehensive internationalization system that supports multiple languages via JSON translation files. The system automatically detects the user's system language and falls back to Portuguese (Brazil) as the default.

## Features

- **Auto-detection**: Automatically detects system language on startup
- **Fallback mechanism**: detected language → pt-BR → en-US
- **Easy integration**: Simple `tr()` function for translations
- **String formatting**: Support for dynamic values via keyword arguments
- **Hot-swappable**: Change language at runtime
- **Extensible**: Easy to add new languages

## Supported Languages

- **pt-BR** (Português Brasil) - Default
- **en-US** (English United States) - Fallback

## Usage

### Basic Translation

```python
from doclayout.core.i18n import tr

# Simple translation
title = tr('menu.file.new')
# Returns: "Novo" (pt-BR) or "New" (en-US)

# With formatting
message = tr('status.file_saved', filename='template.json')
# Returns: "Arquivo salvo: template.json" (pt-BR)
```

### Changing Language

```python
from doclayout.core.i18n import get_translation_manager

tm = get_translation_manager()

# Get available languages
languages = tm.get_available_languages()
# Returns: {'pt-BR': 'Português (Brasil)', 'en-US': 'English (United States)'}

# Change language
success = tm.set_language('en-US')
if success:
    print("Language changed successfully")
```

## Translation File Structure

Translation files are located in `doclayout/translations/` and use JSON format with nested structure:

```json
{
  "_language_name": "Português (Brasil)",
  "_language_code": "pt-BR",
  
  "menu": {
    "file": {
      "title": "Arquivo",
      "new": "Novo",
      "save": "Salvar"
    }
  },
  
  "status": {
    "file_saved": "Arquivo salvo: {filename}",
    "ready": "Pronto"
  }
}
```

### Key Conventions

- Use dot notation for nested keys: `menu.file.new`
- Use `{variable}` for string formatting placeholders
- Metadata keys start with underscore: `_language_name`, `_language_code`

## Adding a New Language

1. **Create translation file**:
   ```bash
   cd doclayout/translations/
   cp pt-BR.json es-ES.json
   ```

2. **Update metadata**:
   ```json
   {
     "_language_name": "Español (España)",
     "_language_code": "es-ES",
     ...
   }
   ```

3. **Translate all strings**: Translate each value while keeping keys unchanged

4. **Test**: Restart application - new language will be auto-detected

## Available Translation Keys

### Menu System
- `menu.file.*` - File menu items
- `menu.edit.*` - Edit menu items
- `menu.view.*` - View menu items
- `menu.insert.*` - Insert menu items
- `menu.arrange.*` - Arrange menu items
- `menu.tools.*` - Tools menu items
- `menu.help.*` - Help menu items

### Status Messages
- `status.ready` - Ready state
- `status.file_saved` - File saved (with filename)
- `status.file_loaded` - File loaded (with filename)
- `status.pdf_exported` - PDF exported (with filename)
- `status.preview_generated` - Preview generated (with filename)
- `status.new_document` - New document created

### Dialog Messages
- `dialog.error.*` - Error dialogs
- `dialog.warning.*` - Warning dialogs
- `dialog.info.*` - Information dialogs
- `dialog.confirm_exit.*` - Exit confirmation

### Properties Panel
- `properties.*` - All property labels and controls

### Element Types
- `element_types.*` - Names of all element types

## Implementation Details

### TranslationManager Class

Singleton class that manages all translations:

```python
class TranslationManager:
    def __init__(self):
        # Auto-detect system language
        # Load translation files
        # Setup fallback chain
        
    def get(self, key: str, **kwargs) -> str:
        # Navigate nested dict using dot notation
        # Apply string formatting if kwargs provided
        # Return key as fallback if not found
        
    def set_language(self, language: str) -> bool:
        # Validate language exists
        # Load new translation file
        # Return success status
```

### Language Detection

The system detects language in the following order:

1. **Exact match**: `pt_BR` → `pt-BR`
2. **Prefix match**: `pt_PT` → `pt-BR` (first pt-* language)
3. **Default**: Falls back to `pt-BR`
4. **Ultimate fallback**: `en-US` if default not found

### Performance

- Translation files loaded once at startup
- Cached in memory for fast access
- No performance impact on runtime
- Minimal memory footprint (~50KB per language)

## Best Practices

1. **Always use translation keys**: Never hardcode UI strings
2. **Descriptive keys**: Use clear, hierarchical key names
3. **Consistent formatting**: Use same placeholder names across languages
4. **Complete translations**: Ensure all keys exist in all language files
5. **Test all languages**: Verify UI layout works with longer/shorter translations

## Troubleshooting

### Translation not found
- Check key spelling and case sensitivity
- Verify key exists in translation file
- Check JSON syntax is valid
- Look for missing commas or brackets

### Wrong language displayed
- Check system locale settings
- Verify translation file exists for your language
- Check `_language_code` matches filename
- Try explicitly setting language via API

### Formatting errors
- Ensure placeholder names match between translation and code
- Use double braces `{{` to escape literal braces
- Check for typos in placeholder names

## Future Enhancements

- GUI language selector in settings
- Runtime language switching without restart
- Translation validation tool
- Automatic missing key detection
- Pluralization support
- Date/time formatting per locale
